import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/frontend/utils/supabase/server';

export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ propertyId: string }> }
) {
    const { propertyId } = await params;
    const supabase = await createClient();
    const { searchParams } = new URL(request.url);

    const itemId = searchParams.get('itemId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const limit = parseInt(searchParams.get('limit') || '100');

    try {
        let query = supabase
            .from('stock_movements')
            .select(`
                *,
                item:stock_items(id, name, item_code),
                user:users(id, full_name)
            `)
            .eq('property_id', propertyId)
            .order('created_at', { ascending: false })
            .limit(limit);

        if (itemId) {
            query = query.eq('item_id', itemId);
        }

        if (startDate) {
            query = query.gte('created_at', startDate);
        }

        if (endDate) {
            query = query.lte('created_at', endDate);
        }

        const { data: movements, error } = await query;

        if (error) {
            return NextResponse.json({ error: error.message }, { status: 500 });
        }

        return NextResponse.json({
            success: true,
            movements,
            total: movements?.length || 0,
        });
    } catch (err) {
        return NextResponse.json(
            { error: err instanceof Error ? err.message : 'Unknown error' },
            { status: 500 }
        );
    }
}

export async function POST(
    request: NextRequest,
    { params }: { params: Promise<{ propertyId: string }> }
) {
    const { propertyId } = await params;
    const supabase = await createClient();

    try {
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        const body = await request.json();
        const { itemId, action, quantity, notes } = body;

        if (!itemId || !action || quantity === undefined || quantity === null) {
            return NextResponse.json(
                { error: 'itemId, action, and quantity are required' },
                { status: 400 }
            );
        }

        if (!['add', 'remove', 'adjust'].includes(action)) {
            return NextResponse.json(
                { error: 'action must be add, remove, or adjust' },
                { status: 400 }
            );
        }

        // Get current item
        const { data: item, error: itemError } = await supabase
            .from('stock_items')
            .select('*')
            .eq('id', itemId)
            .eq('property_id', propertyId)
            .single();

        if (itemError || !item) {
            return NextResponse.json({ error: 'Item not found' }, { status: 404 });
        }

        // Calculate new quantity
        let quantityChange = 0;
        if (action === 'add') {
            quantityChange = quantity;
        } else if (action === 'remove') {
            quantityChange = -quantity;
        } else if (action === 'adjust') {
            quantityChange = quantity - item.quantity;
        }

        const newQuantity = item.quantity + quantityChange;

        // Don't allow negative quantities
        if (newQuantity < 0) {
            return NextResponse.json(
                { error: 'Cannot reduce stock below zero' },
                { status: 400 }
            );
        }

        // Update item quantity
        const { error: updateError } = await supabase
            .from('stock_items')
            .update({
                quantity: newQuantity,
                updated_at: new Date().toISOString(),
            })
            .eq('id', itemId);

        if (updateError) {
            return NextResponse.json({ error: updateError.message }, { status: 500 });
        }

        // Record movement
        const { data: movement, error: movementError } = await supabase
            .from('stock_movements')
            .insert({
                item_id: itemId,
                property_id: propertyId,
                organization_id: item.organization_id,
                action,
                quantity_change: quantityChange,
                quantity_before: item.quantity,
                quantity_after: newQuantity,
                user_id: user.id,
                notes,
            })
            .select()
            .single();

        if (movementError) {
            return NextResponse.json({ error: movementError.message }, { status: 500 });
        }

        return NextResponse.json({
            success: true,
            movement,
            newQuantity,
        }, { status: 201 });
    } catch (err) {
        return NextResponse.json(
            { error: err instanceof Error ? err.message : 'Unknown error' },
            { status: 500 }
        );
    }
}
